% *************************************************************************
%
% Main - script 
%
% This MATLAB script deepens the understanding of the methods and tools that
% are introduced in more detail in the main files of the 'passive dynamic
% walker' and the 'prismatic monoped' examples.  It introduces the
% additional example of a bounding quadruped for which optimal gait
% creation, analysis, and control is performed.  In particular , it shows:  
%
% - (a) How to set up the framework and include all necessary
%       files, folders, and variables 
% - (b) How to run a complex active simulation
% - (c) How to find an optimal periodic solution with a complex active
%       system 
% - (d) How to analyze first order stability and the influence of the
%       control parameters
% - (e) How to create a simplistic linear controller
% - (f) How to simulate a controlled model. 
%
% The following library functions are introduced in this script:
% 
% - HybridDynamics -> Basic Simulation
% - FloquetAnalysis -> For stability analysis
% - Graphic2DSimpleLinkCLASS -> Show a simplified graphical representation 
%                               of the simulation
% - RecordStateCLASS -> Store the states for later use while simulating 
% - FindPeriodicSolution -> For gait creation
% - FindPeriodicSolution_DIRCOL -> For advanced gait creation
% - Struct2Vec -> Convert structs into vectors(which can be specifically 
%                 ordered by name)
%
% Input:  - NONE
% Output: - NONE
%
% Created by C. David Remy on 03/14/2011
% MATLAB 2010a
%
% Documentation:
%  'A MATLAB Framework For Gait Creation', 2011, C. David Remy (1), Keith
%  Buffinton (2), and Roland Siegwart (1),  International Conference on
%  Intelligent Robots and Systems, September 25-30, San Francisco, USA 
%
% (1) Autonomous Systems Lab, Institute of Robotics and Intelligent Systems, 
%     Swiss Federal Institute of Technology (ETHZ) 
%     Tannenstr. 3 / CLA-E-32.1
%     8092 Zurich, Switzerland  
%     cremy@ethz.ch; rsiegwart@ethz.ch
%
% (2) Department of Mechanical Engineering, 
%     Bucknell University
%     701 Moore Avenue
%     Lewisburg, PA-17837, USA
%     buffintk@bucknell.edu
%
%   See also HYBRIDDYNAMICS, FLOWMAP, JUMPMAP, JUMPSET,
%            SYMBOLICCOMPUTATIONOFEQM, CONTSTATEDEFINITION,
%            DISCSTATEDEFINITION, SYSTPARAMDEFINITION, EXCTTATEDEFINITION,
%            EXCTPARAMDEFINITION, COMPUTEDIFFERENTIABLEFORCES,
%            EXCITATIONFUNCTION 
%
%************************************************************************


%% (a) Initial Setup
% Define the necessary directories, so that all library-files of the
% framework and the correct model files can be accessed.  Retrieve all
% initial model states and parameters from the state definition files.

% Make a clean sweep:
clear all
close all
clc
% Define a base directory to make this file easily portable to other computers:
GaitCreationDir = 'D:\GaitCreation_SLIP\gaitcreation';
if ~exist(GaitCreationDir,'dir')
    error('BoundingQuadruped:Main:GaitCreationDirectorNotExist', 'The specified GaitCreation-directory was not found on your computer.  Please adjust this path to match the installiation on your computer')
end
cd([GaitCreationDir,'\Models\BoundingQuadruped']);
% Reset the MATLAB search path to its default value:
path(pathdef);
% Set the path to include all library functions:
path(path,[GaitCreationDir,'\Shared;',...
           GaitCreationDir,'\Shared\Analysis;',...
           GaitCreationDir,'\Shared\Graphics\Misc;',...
           GaitCreationDir,'\Shared\Graphics\SeriesElasticActuation;',...
           GaitCreationDir,'\Shared\Graphics;',...
           GaitCreationDir,'\Shared\Utilities;',...
           GaitCreationDir,'\Shared\Synthesis;']);
% Set the path to include the model specific functions:
% (Every time a different model is processed, it is important to check that
% the path only includes the directories of the current model)
path(path,[GaitCreationDir,'\Models\BoundingQuadruped;',...
           GaitCreationDir,'\Models\BoundingQuadruped\Data;',...
           GaitCreationDir,'\Models\BoundingQuadruped\Dynamics;',...
           GaitCreationDir,'\Models\BoundingQuadruped\Dynamics\AutoGeneratedFcts;',...
           GaitCreationDir,'\Models\BoundingQuadruped\Dynamics\Definitions;',...
           GaitCreationDir,'\Models\BoundingQuadruped\Dynamics\Misc;',...
           GaitCreationDir,'\Models\BoundingQuadruped\Dynamics\WrapperFcts;',...
           GaitCreationDir,'\Models\BoundingQuadruped\Graphics;']);

% Get the basic state and parameter values, their names, and the
% corresponding index mapping.  By this we can access the vectors by name,
% which keeps the structure very general but allows a clear indexing.
[contStateVec, contStateNames, contStateIndices] = ContStateDefinition();
[discStateVec, discStateNames, discStateIndices] = DiscStateDefinition();
[systParamVec, systParamNames, systParamIndices] = SystParamDefinition();
[exctStateVec, exctStateNames, exctStateIndices] = ExctStateDefinition();
[exctParamVec, exctParamNames, exctParamIndices] = ExctParamDefinition();


%% (b) Simulation of a complex active System
% Since the initial values of the state vectors and parameters (As they are
% described in the various definition files) already resemble a nearly
% periodic motion, they can be simply passed to the simulation interface:
yIN = contStateVec;
zIN = discStateVec;
p   = systParamVec;
s   = exctParamVec;
% The '2DSimpleLink' class can be used to graphically illustrate a large
% variety of robotic systems.  It uses the auto-generated functions
% 'LinkPositions', 'FootPtPositions', and 'CoGPositions', which are called
% through the wrapper function 'GraphicalKinematicsWrapper'. 
graphOUTPUT = Graphic2DSimpleLinkCLASS(contStateVec, systParamVec, systParamVec(systParamIndices.rFoot), [0.6, 0.2, 0.2, 0.2, 0.2]/4);
simOptions.tIN  = 0;  % The simulation will start at t = 

simOptions.tMAX = 5;  % The simulation will abort the latest when t reaches 5.
% Run a standard simulation without any return parameters.  This is done
% just to get a visual impression of the motion of the model:
HybridDynamics(yIN, zIN, p, @ExcitationFunction, s, graphOUTPUT, simOptions);


%% (c) Find an optimal periodic solution with 5 Fourier terms in the
%% excitation functions: 
% Set up the optimization problem:
% INITIAL GUESS:
% The provided initial states (which are already quite good) are used as
% initial guess for the gait search:
yINIT = contStateVec;
zINIT = discStateVec;
pINIT = systParamVec;
sINIT = exctParamVec;
% WHAT TO OPTIMIZE:
% Since almost all continuous states are subject to optimization, we
% specify the ones that must not be altered:
yOPTIM = ones(size(yINIT));  % optimize everything...
% ... apart from the horizontal starting position (should be 0), vertical
% velocity (every motion should start at apex transit, i.e. dy=0), time
% (must be 0 to be periodic), and positive work (must start at 0 to get
% comparable results)    
yOPTIM(contStateIndices.x)       = 0;
yOPTIM(contStateIndices.dy)      = 0;
yOPTIM(contStateIndices.time)    = 0;
yOPTIM(contStateIndices.posWork) = 0;
% Initial continuous states are not altered
zOPTIMstruct = struct();
zOPTIM = Struct2Vec(zOPTIMstruct, discStateNames);
% In contrast to the one legged hopper, where the resting leg angle was
% fixed to be vertically downward with respect to the main body (it was
% essentially set by adjusting the initial pitch angle of the robot), the
% leg angles and the main body pitch are coupled in this example, and must
% be optimized for separately: 
pOPTIMstruct.alphaF_0 = 1;
pOPTIMstruct.alphaB_0 = 1;
pOPTIM = Struct2Vec(pOPTIMstruct, systParamNames);
% Find the right excitation-frequency:
sOPTIMstruct.strideFreq = 1; 
% The first nrTerms (=5) pairs of Fourier-coefficients for leg extension,
% and hip swing will be altered: 
nrTerms = 5;
sOPTIMstruct.sinlF(1:nrTerms)     = 1;
sOPTIMstruct.coslF(1:nrTerms)     = 1;
sOPTIMstruct.sinalphaF(1:nrTerms) = 1;
sOPTIMstruct.cosalphaF(1:nrTerms) = 1;
sOPTIMstruct.sinlB(1:nrTerms)     = 1;
sOPTIMstruct.coslB(1:nrTerms)     = 1;
sOPTIMstruct.sinalphaB(1:nrTerms) = 1;
sOPTIMstruct.cosalphaB(1:nrTerms) = 1;
sOPTIM = Struct2Vec(sOPTIMstruct, exctParamNames);
% WHAT TO MAKE PERIODIC:
% Almost everything must be periodic...
yPERIOD = ones(size(yINIT));
% ... apart from horizontal position, time, and energy consumption.
yPERIOD(contStateIndices.x)       = 0;
yPERIOD(contStateIndices.time)    = 0;
yPERIOD(contStateIndices.posWork) = 0;
% The following requirements should be a side-product of periodicity in the
% continuous states, but might tell us if something goes wrong:
zPERIODstruct.phaseF = 1; 
zPERIODstruct.phaseB = 1;
zPERIOD = Struct2Vec(zPERIODstruct, discStateNames);
% COMPOSE THE COST FUNCTION:
% No cost contribution from the continuous states:
yCOSTstruct = struct();
yCOST = Struct2Vec(yCOSTstruct, contStateNames);
% Only the COT contributes to the cost function:
zCOSTstruct.COT = 1; 
zCOST = Struct2Vec(zCOSTstruct, discStateNames);
% No cost contribution from the system parameters:
pCOSTstruct = struct();
pCOST = Struct2Vec(pCOSTstruct, systParamNames);
% No cost contribution from the excitation parameters:
sCOSTstruct = struct();
sCOST = Struct2Vec(sCOSTstruct, exctParamNames);

% The yDependency helps speeding up the computation of the Jacobian in the
% optimization by telling the optimizer which derivatives depend on which
% states: 
yDEPENDENCYstruct.x       =  0;  % This state has no impact on the right hand side of the ODE -> '0'
yDEPENDENCYstruct.dx      =  1;  % This state IS the derivative of state #1 ('x') ->'1'
yDEPENDENCYstruct.y       =  0;  % This state has no impact on the right hand side of the ODE -> '0'
yDEPENDENCYstruct.dy      =  3;  % This state IS the derivative of state #3 ('y') ->'3'
yDEPENDENCYstruct.phi     = -1;  % This an all following states impact the right hand side of the ODE
yDEPENDENCYstruct.dphi    = -1; 
yDEPENDENCYstruct.alphaF  = -1; 
yDEPENDENCYstruct.dalphaF = -1; 
yDEPENDENCYstruct.lF      = -1; 
yDEPENDENCYstruct.dlF     = -1; 
yDEPENDENCYstruct.alphaB  = -1; 
yDEPENDENCYstruct.dalphaB = -1; 
yDEPENDENCYstruct.lB      = -1; 
yDEPENDENCYstruct.dlB     = -1; 
yDEPENDENCYstruct.time    = -1; 
yDEPENDENCYstruct.posWork =  0;  % This state has no impact on the right hand side of the ODE -> '0'
dircolOptions.yDependency = Struct2Vec(yDEPENDENCYstruct,contStateNames);

% While direct collocation greatly improves and accelerates the
% optimization, it comes with the big drawback, that the order of 'events'
% must be pre-defined a priori.  This is a trivial constraint for simple
% systems like a one-legged hopper, but for the bounding quadruped it means
% that we have to specify a destinct foot-fall sequence beforehand. In the
% current case this is air-phase, back-stance, double-stance, front-stance,
% air-phase.  The corresponding event-sequence (event # in parenthesis)
% that is passed to the optimizer is thus: 'Back touch down (3)', 'Front
% touch down (1)', 'Back lift off (4)', 'Front lift off (2)', 'Stride time
% reached (5)':
dircolOptions.ordEvents  = [3 1 4 2 5]; 
% The number of segments (which define the grid-size of the direct
% colloction) is selected evenly for all integration intervals: 
dircolOptions.nPerInterval = [15 15 15 15 15];
% Because of the complexity of the system (and the high number of
% excitation terms), this algorithm might require a large number of
% function evaluations and iterations:
dircolOptions.numOPTS = optimset('MaxFunEvals',20000,'MaxIter',10000);
% Run the optimizer:
[yCYC, zCYC, pCYC, sCYC, tEVENT_CYC, yGRID_CYC, costValue] =...
    FindPeriodicSolution_DIRCOL(@HybridDynamics, yINIT,   zINIT,  pINIT,  @ExcitationFunction, sINIT,... 
                                                 yOPTIM,  zOPTIM, pOPTIM,                      sOPTIM,... 
                                                 yPERIOD, zPERIOD, ...
                                                 yCOST,   zCOST,  pCOST,                       sCOST,... 
                                                 dircolOptions);
% Store the results (and the configuration of the optimization) in a file for later use:
save('Data\OptimalBounding.mat','yCYC',    'zCYC',   'pCYC',   'sCYC', 'tEVENT_CYC', 'yGRID_CYC',...
                                'costValue',...
                                'yINIT',   'zINIT',  'pINIT',  'sINIT',... 
                                'yOPTIM',  'zOPTIM', 'pOPTIM', 'sOPTIM',... 
                                'yPERIOD', 'zPERIOD', ...
                                'yCOST',   'zCOST',  'pCOST',  'sCOST',... 
                                'dircolOptions');
load('Data\OptimalBounding.mat')
% Simulation of the final, optimal and periodic solution:
graphOUTPUT = Graphic2DSimpleLinkCLASS(contStateVec, systParamVec, systParamVec(systParamIndices.rFoot), [0.6, 0.2, 0.2, 0.2, 0.2]/4);
simOptions.tIN  = 0;  % The simulation will start at t = 0
simOptions.tMAX = 5;  % The simulation will abort the latest when t reaches 5.
HybridDynamics(yCYC, zCYC, pCYC, @ExcitationFunction, sCYC, graphOUTPUT, simOptions);



%% (d) Stability Analysis:
% In this example, it is shown how the linear first-order stability
% analysis can be extended onto the parameters of the excitation function,
% which allows the creation of a stable controller.
% Since in the computation of the Monodromy matrix is done simulating each
% stride using direct shooting, it is important to first generate a truly
% periodic solution using direct shooting as algorithm.  This should
% converge in a couple of iterations, since the initial conditions are
% already very close to being 'perfect':
% Use the cyclic initial conditions as initial guess...
yINIT = yCYC;
zINIT = zCYC;
pINIT = pCYC;
sINIT = sCYC;
% ...and run the optimization (it's actually just an identification of a
% periodic motion, without caring about the cost function) using the same
% parameters as above:
solveOptions.tMAX = 5;
[yCYC, zCYC, pCYC, sCYC] =...
    FindPeriodicSolution(@HybridDynamics, yINIT,   zINIT,  pINIT,  @ExcitationFunction, sINIT,... 
                                                 yOPTIM,  zOPTIM, pOPTIM,                      sOPTIM,... 
                                                 yPERIOD, zPERIOD, ...
                                                 solveOptions);
                                             
% We want to analyse the reaction to disturbances of all states that should
% be periodic:
yANALYS = yPERIOD;
% Disturbances in the discrete states do not make sense in this example
% since the phase values are discrete and the COT is not periodic.
zANALYS = zeros(size(zCYC));
% Additionally, we now also examine how the system reacts to disturbances
% in the excitation parameters.  In the controller this knowledge will be
% used to modulate the excitation inputs (i.e. alter the excitation
% parameters) to react to a disturbance in the continuous states:
sANALYS = sOPTIM;
% Run the analysis
% This function additionally returns the Monodromy matrix for disturbances
% in x (composed as x=[y,z]), and s.  Both matrices only cover states and
% parameters that were subject to analysis. I.e., size(Jx)= [n,n] and
% size(Js) = [n,m], where n=nnz(yANALYS)+nnz(zANALYS) and m=nnz(sANALYS):  
[eigenValuesCYC, eigenVectorsCYC, Jx, Js] =  FloquetAnalysis(@HybridDynamics, yCYC,    zCYC,   pCYC, @ExcitationFunction, sCYC, ... 
                                                                              yANALYS, zANALYS,                           sANALYS);
% Save these results to a file
save('Data\OptimalBoundingAnalysis.mat','yCYC',    'zCYC',   'pCYC',   'sCYC', 'tEVENT_CYC', 'yGRID_CYC',...
                                        'yANALYS', 'zANALYS',          'sANALYS',...
                                        'eigenValuesCYC', 'eigenVectorsCYC', 'Jx', 'Js')
% Graphically show the eigenvalues of the uncontrolled system:                                                                          
load('Data\OptimalBoundingAnalysis.mat')                                    
figure('Name','Bounding Quadruped: Eigenvalues of the uncontrolled system','WindowStyle','docked');
hold on; grid on; box on;
% Plot the unit circle
plot(sin(linspace(0,2*pi)),cos(linspace(0,2*pi)),'r')
axis equal
% Plot the individual eigenvalues:
plot(real(eigenValuesCYC),imag(eigenValuesCYC),'ro','MarkerSize',6,'LineStyle','none')
% Graph annotation:
xlabel('Re')
ylabel('Im') 
axis([-2, 2, -2, 2])

%% (e) Create a controller
% In the following, we design a simple linear state-feedback controller for
% the bounding quadruped the basic idea is to use the first order
% linearization of the Poincare map and react to disturbance in the
% continuous states y, by modulating the excitation parameters s:
% The first order response of the system can be stated as:
% x(k+1) = Jx*delta_x + Js*delta_s (where x is the combined state vector
% [y,z]).
% The linear controller delta_s = K*delta_x can be choosen arbitrarily, as
% long as we make sure that the excitation function u = u(y,z,s) = u(t,s)
% is periodic and continuously differentiable across strides, when the
% excitation parameters s are changed (since it must be followed by a servo
% controlled motor).  This means:  u(t=0,s+delta_s)=u(t=T_stride,s) and
% du(t=0,s+delta_s)/dt=du(t=T_stride,s)/dt for all modulations delta_s
% For a fixed stride frequency f_stride, u(t=0,s) is linear in the Fourier
% coefficients, and we thus can decompose and state: u(t,s+delta_s) =
% u(t,s) + u(t,delta_s) -> u(t=0,delta_s) = u(t=T_stride,delta_s) = 0,
% which can be enforced by a linear constraint matrix C.
load('Data\OptimalBounding.mat')
load('Data\OptimalBoundingAnalysis.mat')                                    
% In the following we define a desired disturbance response Jdes of the
% closed loop system: 
% x(k+1) = Jx*delta_x + Js*delta_s = Jx*delta_x + Js*K*delta_x = Jdes * delta_x
% To this end, all unstable eigenvalues are reduced to a magnitude of 0.6:
eigenValuesCYCdes = eigenValuesCYC;
for i = 1:length(eigenValuesCYC)
    if norm(eigenValuesCYC(i))>1;
        eigenValuesCYCdes(i) = eigenValuesCYC(i)/norm(eigenValuesCYC(i))*0.6;
    else
        eigenValuesCYCdes(i) = eigenValuesCYC(i);
    end
end
Jdes = real(eigenVectorsCYC*diag(eigenValuesCYCdes)/eigenVectorsCYC);
[eigenVectorsDES, D] = eig(Jdes);
eigenValuesDES = diag(D);
% Show the eigenvalues of the uncontrolled and the controlled system:                                                                          
figure('Name','Bounding Quadruped: Eigenvalues of the controlled and uncontrolled system','WindowStyle','docked');
hold on; grid on; box on;
% Plot the unit circle
plot(sin(linspace(0,2*pi)),cos(linspace(0,2*pi)),'r')
axis equal
% Plot the eigenvalues of the uncontrolled system:
plot(real(eigenValuesCYC),imag(eigenValuesCYC),'ro','MarkerSize',6,'LineStyle','none')
% Plot the eigenvalues of the controlled system:
plot(real(eigenValuesDES),imag(eigenValuesDES),'bx','MarkerSize',6,'LineStyle','none')
% Graph annotation:
xlabel('Re')
ylabel('Im') 
axis([-2, 2, -2, 2])
% Compose the constraint Matrix C to ensure that the actuator motion is
% periodic over several steps even when the controller is running.  When
% written as a linear constraint, C*delta_s = 0, this means for the
% constraint matrix C... 
C = [] ; % will be expanded row-by-row
nrTerms = 5;  % The controller should only act on 
% ...(I) The stride-frequency must be constant:
sCONSTstruct = []; sCONSTstruct.strideFreq = 1;
C = [C;Struct2Vec(sCONSTstruct,exctParamNames)'];
% ...( II) The sum of changes in the sine-terms must even out over all
% terms, to keep the function periodic for each leg:
sCONSTstruct = []; sCONSTstruct.sinalphaF = ones(1,nrTerms);
C = [C;Struct2Vec(sCONSTstruct,exctParamNames)'];
sCONSTstruct = []; sCONSTstruct.sinlF     = ones(1,nrTerms);
C = [C;Struct2Vec(sCONSTstruct,exctParamNames)'];
sCONSTstruct = []; sCONSTstruct.sinalphaB = ones(1,nrTerms);
C = [C;Struct2Vec(sCONSTstruct,exctParamNames)'];
sCONSTstruct = []; sCONSTstruct.sinlB     = ones(1,nrTerms);
C = [C;Struct2Vec(sCONSTstruct,exctParamNames)'];
% ...(III) The sum of changes in the cosine-terms multiplied by
% corresponding harmonic must even out over all terms, to keep the first
% derivative of the actuator motion periodic: 
sCONSTstruct = []; sCONSTstruct.cosalphaF = 1:nrTerms;
C = [C;Struct2Vec(sCONSTstruct,exctParamNames)'];
sCONSTstruct = []; sCONSTstruct.coslF     = 1:nrTerms;
C = [C;Struct2Vec(sCONSTstruct,exctParamNames)'];
sCONSTstruct = []; sCONSTstruct.cosalphaB = 1:nrTerms;
C = [C;Struct2Vec(sCONSTstruct,exctParamNames)'];
sCONSTstruct = []; sCONSTstruct.coslB     = 1:nrTerms;
C = [C;Struct2Vec(sCONSTstruct,exctParamNames)'];
% Show the structure of the constrain matrix C:
figure('Name','Bounding Quadruped: Constraint matrix structure','WindowStyle','docked');
% Show a bar-graph with the matrix values:
bar3(C);view(3)
% We have to recall that the two Monodromy matrices only cover states and
% parameters that were subject to analysis. I.e., size(Jx)= [n,n] and
% size(Js) = [n,m], where n=nnz(yANALYS)+nnz(zANALYS) and m=nnz(sANALYS).
% This means, that the controller equations stated above, should be written
% using reduced states s_red and x_red, which can be generated with the
% following two selection matrices: 
% s_red = Ss * s;
% x_red = Sx * [y;z];
% I.e.: 
% Sx*[y(k+1);z(k+1)] = Jx*Sx*[delta_y;delta_z] + Js*Ss*delta_s =...
%    (Jx + Js*K)*Sx*[delta_y;delta_z] = Jdes*Sx*[delta_y;delta_z]
% For the constraints we have to make sure that  C*delta_s = 0 ->
% C*Ss'*K*delta_x=C*Ss'*K*Sx*[delta_y;delta_z]=0 for all delta_x
% (Sx*[delta_y;delta_z]), and thus: C*Ss'*K=0: 
%
% -> K = pinv([Js;C*Ss'])*[Jdes-Jx;0])
%
% Create the selection matrices:
I = eye(length(sCYC));
Ss = I(sANALYS==1,:);
I = eye(length(yCYC)+length(zCYC));
Sx = I([yANALYS==1;zANALYS==1],:);
% Compute the controller matrix:
K = pinv([Js;C*Ss'])*[Jdes-Jx;zeros(size(C,1),size(Jx,2))];
% With this controller, the necessary modulations can be computed according
% to:
% delta_s = Ss'*K*Sx*[delta_y;delta_z];
%
% Save the controller to a file
save('Data\OptimalBoundingController.mat','K', 'Sx', 'Ss');



%% (f) Compare the controlled and the uncontrolled system 
% Simulations of the undisturbed (i.e., reference) system, the disturbed
% system and the controlled system are performed.  The controller must be
% implemented outside the simulation interface and is called after every
% loop to adjust the excitation parameters   
% For each configuration, 6 steps are simulated:
nr_steps = 6;
% Load the solution, analysis and the controller:
load('Data\OptimalBounding.mat')
load('Data\OptimalBoundingAnalysis.mat')                                    
load('Data\OptimalBoundingController.mat')                                    
% Prepare...
% ...the simulation of the reference motion:
recOUTPUT_ref = RecordStateCLASS();    
simOptions_ref.tIN  = 0;
simOptions_ref.tMAX = 20;
yIN_ref = yCYC;
zIN_ref = zCYC;
 ...the simulation of  the disturbed motion:
recOUTPUT_dist = RecordStateCLASS();    
simOptions_dist.tIN  = 0;
simOptions_dist.tMAX = 20;
yIN_dist = yCYC;
% All continuous states are disturbed by 10%:
yIN_dist(yPERIOD==1) = yIN_dist(yPERIOD==1)*1.1;
zIN_dist = zCYC;
 ...the simulation of disturbed and controlled motion:
recOUTPUT_cntr = RecordStateCLASS();    
simOptions_cntr.tIN  = 0;
simOptions_cntr.tMAX = 20;
yIN_cntr = yCYC;
% All continuous states are disturbed by 10%:
yIN_cntr(yPERIOD==1) = yIN_cntr(yPERIOD==1)*1.1;
zIN_cntr = zCYC;
% Run the simulation for each configuration:
for i = 1:nr_steps
    % Reference:
    [yOUT_ref,  zOUT_ref,  tOUT_ref,  recOUTPUT_ref]  = HybridDynamics(yIN_ref,  zIN_ref,  pCYC, @ExcitationFunction, sCYC,  recOUTPUT_ref,  simOptions_ref);
    simOptions_ref.tIN  = tOUT_ref + 0; simOptions_ref.tMAX = tOUT_ref + 5; yIN_ref = yOUT_ref; zIN_ref = zOUT_ref;
    % Disturbed:
    [yOUT_dist, zOUT_dist, tOUT_dist, recOUTPUT_dist] = HybridDynamics(yIN_dist, zIN_dist, pCYC, @ExcitationFunction, sCYC,  recOUTPUT_dist, simOptions_dist);
    simOptions_dist.tIN  = tOUT_dist + 0; simOptions_dist.tMAX = tOUT_dist + 5; yIN_dist = yOUT_dist; zIN_dist = zOUT_dist;
    % Controlled:
    sCONT = sCYC + Ss'*K*Sx*[yIN_cntr-yCYC; zIN_cntr-zCYC];
    [yOUT_cntr, zOUT_cntr, tOUT_cntr, recOUTPUT_cntr] = HybridDynamics(yIN_cntr, zIN_cntr, pCYC, @ExcitationFunction, sCONT, recOUTPUT_cntr, simOptions_cntr);
    simOptions_cntr.tIN  = tOUT_cntr + 0; simOptions_cntr.tMAX = tOUT_cntr + 5; yIN_cntr = yOUT_cntr; zIN_cntr = zOUT_cntr;
end
% Retrieve the results:
simRES_ref  = recOUTPUT_ref.retrieve();
simRES_dist = recOUTPUT_dist.retrieve();
simRES_cntr = recOUTPUT_cntr.retrieve();
% Plot them:
figure('Name','Bounding Quadruped: Reference, Disturbed, and Controlled response','WindowStyle','docked')
hold on; grid on; box on;
h(1) = plot(simRES_ref.t,simRES_ref.continuousStates(contStateIndices.y,:),'k-');
h(2) = plot(simRES_dist.t,simRES_dist.continuousStates(contStateIndices.y,:),'r-');
h(3) = plot(simRES_cntr.t,simRES_cntr.continuousStates(contStateIndices.y,:),'b-');
h(4) = plot(simRES_ref.t,simRES_ref.continuousStates(contStateIndices.phi,:),'k:');
h(5) = plot(simRES_dist.t,simRES_dist.continuousStates(contStateIndices.phi,:),'r:');
h(6) = plot(simRES_cntr.t,simRES_cntr.continuousStates(contStateIndices.phi,:),'b:');
xlabel('t [norm units]');
ylabel('y/\phi  [norm units]');
axis([0,nr_steps/sCYC(exctParamIndices.strideFreq),-0.5,1.5])
% Create the first three entries of the legend:
legend(h(1:3),'y-ref.','y-dist.','y-cntr.','Location','West');
% Create a second axis to be able to put in a second legend
ah = axes('position',get(gca,'position'),'visible','off');
legend(ah,h(4:6),'\phi-ref.','\phi-dist.','\phi-cntr.','Location','East');
% Save the figure to image files:
fig = gcf; set(fig, 'PaperType','<custom>', 'PaperSize',[20,10], 'PaperPosition', [0,0,20,10])
print(fig,'-r600','-depsc','-tiff','Figure6.eps');
print(fig,'-r600','-djpeg','Figure6.jpg');
% Create a nice rendering to compare the controlled and the uncontrolled
% solution.
% Set up graphical output:
graph3DOUTPUT = BoundingQuadruped3DCLASS(true);
n = 50*nr_steps; % # of frames per step * nr_steps
% Create a timing sequence for the frames of each solution:
tFrame_dist = linspace(0, simRES_dist.t(end), n+1);
tFrame_cntr = linspace(0, simRES_cntr.t(end), n+1);
% If desired, every iteration a rendered picture is saved to disc. This
% can later be used to create an animation of the quadruped.
% (un)comment the following lines, if you (don't) want to save the
% individual frames to disc:
%  frameCount = 0; 
%  mkdir MovieFramesBoundingQuadruped
%  fig = gcf;set(fig, 'PaperPosition', [0.634517 6.34517 20.3046 15.2284/2])
% For each step
for j = 1:n
    y = interp1(simRES_dist.t + linspace(0,1e-5,length(simRES_dist.t)), simRES_dist.continuousStates', tFrame_dist(j))';
    z = interp1(simRES_dist.t + linspace(0,1e-5,length(simRES_dist.t)), simRES_dist.discreteStates', tFrame_dist(j))';
    u = interp1(simRES_dist.t + linspace(0,1e-5,length(simRES_dist.t)), simRES_dist.excitationStates', tFrame_dist(j))';
    graph3DOUTPUT.update(y,z,[],u);
    % (un)comment the following line, if you (don't) want to save the
    % individual frames to disc:
    %  fig = gcf;print(fig,'-r600','-djpeg','MovieFramesBoundingQuadruped/DistFrame.jpg','-zbuffer'); 
    y = interp1(simRES_cntr.t + linspace(0,1e-5,length(simRES_cntr.t)), simRES_cntr.continuousStates', tFrame_cntr(j))';
    z = interp1(simRES_cntr.t + linspace(0,1e-5,length(simRES_cntr.t)), simRES_cntr.discreteStates', tFrame_cntr(j))';
    u = interp1(simRES_cntr.t + linspace(0,1e-5,length(simRES_cntr.t)), simRES_cntr.excitationStates', tFrame_cntr(j))';
    graph3DOUTPUT.update(y,z,[],u);
    % (un)comment the following lines, if you (don't) want to save the
    % individual frames to disc:
    %  fig = gcf;print(fig,'-r600','-djpeg','MovieFramesBoundingQuadruped/CntrFrame.jpg','-zbuffer'); 
    %  % Combine the two images into one movie frame:
    %  D = imread('MovieFramesBoundingQuadruped/DistFrame.jpg');
    %  C = imread('MovieFramesBoundingQuadruped/CntrFrame.jpg');
    %  E = [D;C];
    %  imwrite(E,['MovieFramesBoundingQuadruped/Frame',num2str(frameCount,'%04d.jpg')]);  frameCount = frameCount + 1;
end