% script SymbolicComputationOfEQM
%
% This MATLAB script performs the symbolic computation of the individual
% components of the equations of motion (Mass Matrix, Differentiable
% Forces, etc.).  The resulting functions are saved as automatically
% generated mat-files in the directory 'AutoGeneratedFcts'.  
% 
% The produced functions describe the dynamics ('M', 'f_cg') and the
% kinematics of the contact points ('cont_pointF', 'JF', 'dJFdtTIMESdqdt',
% 'cont_pointB', 'JB', 'dJBdtTIMESdqdt'), CoGs ('CoGs'), and links
% ('links', 'footPts') of a bounding quadruped.  
% 
%
% Input:  - NONE
% Output: - function M              = MassMatrix(q, param)
%         - function f_cg           = F_CoriGrav(q, dqdt, param)
%         - function cont_pointF    = ContactPointF(q, param)
%         - function cont_pointB    = ContactPointB(q, param)
%         - function JF             = ContactJacobianF(q, param)
%         - function JB             = ContactJacobianB(q, param)
%         - function dJFdtTIMESdqdt = ContactJacobianFDtTIMESdqdt(q, dqdt, param)
%         - function dJBdtTIMESdqdt = ContactJacobianBDtTIMESdqdt(q, dqdt, param)
%         - function CoGs           = CoGPositions(q, param)
%         - function links          = LinkPositions(q, param)
%         - function footPts        = FootPtPositions(q, param)
%
% where q are the generalized coordinates q = [x y phi alphaF lF alphaB
% lB], dqdt the generalized speeds dqdt = dx dy dphi dalphaF dlF dalphaB
% dlB], and param is a reduced vector of mass and kinematic parameters
% param = [l1 l2 l3 rFoot g m1 m2 m3 j1 j2 j3].   
%
% NOTE:  The constructed functions are not called directly, but through a
% number of wrapper functions which reflect the definition of the
% state vector 'y' and parameter vector 'p'.
%
% Created by C. David Remy on 03/14/2011
% MATLAB 2010a 
% (uses the symbolic math toolbox)
%
% Documentation:
%  'A MATLAB Framework For Gait Creation', 2011, C. David Remy (1), Keith
%  Buffinton (2), and Roland Siegwart (1),  International Conference on
%  Intelligent Robots and Systems, September 25-30, San Francisco, USA 
%
% (1) Autonomous Systems Lab, Institute of Robotics and Intelligent Systems, 
%     Swiss Federal Institute of Technology (ETHZ) 
%     Tannenstr. 3 / CLA-E-32.1
%     8092 Zurich, Switzerland  
%     cremy@ethz.ch; rsiegwart@ethz.ch
%
% (2) Department of Mechanical Engineering, 
%     Bucknell University
%     701 Moore Avenue
%     Lewisburg, PA-17837, USA
%     buffintk@bucknell.edu
%
%   See also FLOWMAP, JUMPMAP, JUMPSET, GRAPHIC2DSIMPLELINKCLASS,
%            MASSMATRIXWRAPPER, GRAPHICALKINEMATICSWRAPPER,
%            CONTACTKINEMATICSWRAPPERF, CONTACTKINEMATICSWRAPPERB,
%            F_CORIGRAVWRAPPER. 


%% Definitions
% Generalized coordinates...
syms x y phi alphaF lF alphaB lB
q    = [x y phi alphaF lF alphaB lB];
% ... and generalized speeds
syms dx dy dphi dalphaF dlF dalphaB dlB
dqdt = [dx dy dphi dalphaF dlF dalphaB dlB];

% Define the necessary parameter subset:
% Gravity
syms g
% Segment dimensions:
syms l1 l2 l3 rFoot
% Masses/Inertia;
syms m1 m2 m3
syms j1 j2 j3
param = [l1 l2 l3 rFoot g m1 m2 m3 j1 j2 j3];

%% DYNAMICS (obtained via the Euler-Lagrange equation)

% CoG-orientations (from kinematics):
CoG_MB_ang     = phi;
CoG_ThighF_ang = phi+alphaF;
CoG_FootF_ang  = phi+alphaF;
CoG_ThighB_ang = phi+alphaB;
CoG_FootB_ang  = phi+alphaB;
% CoG-positions (from kinematics):
CoG_MB    = [x;
             y];
CoG_ThighF = [x + l1 * cos(CoG_MB_ang) + l2 * sin(CoG_ThighF_ang);
              y + l1 * sin(CoG_MB_ang) - l2 * cos(CoG_ThighF_ang)];
CoG_FootF  = [x + l1 * cos(CoG_MB_ang) + (lF-l3) * sin(CoG_FootF_ang);
              y + l1 * sin(CoG_MB_ang) - (lF-l3) * cos(CoG_FootF_ang)];
CoG_ThighB = [x - l1 * cos(CoG_MB_ang) + l2 * sin(CoG_ThighB_ang);
              y - l1 * sin(CoG_MB_ang) - l2 * cos(CoG_ThighB_ang)];
CoG_FootB  = [x - l1 * cos(CoG_MB_ang) + (lB-l3) * sin(CoG_FootB_ang);
              y - l1 * sin(CoG_MB_ang) - (lB-l3) * cos(CoG_FootB_ang)];
         
% CoG-velocities (computed via jacobians):
d_CoG_MB    = jacobian(CoG_MB,q)*dqdt.';
d_CoG_ThighF = jacobian(CoG_ThighF,q)*dqdt.';
d_CoG_FootF  = jacobian(CoG_FootF,q)*dqdt.';
d_CoG_ThighB = jacobian(CoG_ThighB,q)*dqdt.';
d_CoG_FootB  = jacobian(CoG_FootB,q)*dqdt.';
d_CoG_MB_ang    = jacobian(CoG_MB_ang,q)*dqdt.';
d_CoG_ThighF_ang = jacobian(CoG_ThighF_ang,q)*dqdt.';
d_CoG_FootF_ang  = jacobian(CoG_FootF_ang,q)*dqdt.';
d_CoG_ThighB_ang = jacobian(CoG_ThighB_ang,q)*dqdt.';
d_CoG_FootB_ang  = jacobian(CoG_FootB_ang,q)*dqdt.';

% Potential Energy (due to gravity):
V = CoG_MB(2)*m1*g + CoG_ThighF(2)*m2*g + CoG_FootF(2)*m3*g + CoG_ThighB(2)*m2*g + CoG_FootB(2)*m3*g;
V = simple(factor(V));

% Kinetic Energy:         
T = 0.5 * (m1 * sum(d_CoG_MB.^2) + ...
           m2 * sum(d_CoG_ThighF.^2) + ...
           m3 * sum(d_CoG_FootF.^2) + ...
           m2 * sum(d_CoG_ThighB.^2) + ...
           m3 * sum(d_CoG_FootB.^2) + ...
           j1 * d_CoG_MB_ang^2 + ...
           j2 * d_CoG_ThighF_ang^2 + ...
           j3 * d_CoG_FootF_ang^2 + ...
           j2 * d_CoG_ThighB_ang^2 + ...
           j3 * d_CoG_FootB_ang^2);
T = simple(factor(T));

% Lagrangian:
L = T-V;
% Partial derivatives:
dLdq   = jacobian(L,q).';
dLdqdt = jacobian(L,dqdt).';
      
% Compute Mass Matrix:
M = jacobian(dLdqdt,dqdt);
%M = simple(M);

% Compute the coriolis and gravitational forces:
dL_dqdt_dt = jacobian(dLdqdt,q)*dqdt.';
f_cg = dLdq - dL_dqdt_dt;
%f_cg = simple(f_cg);

% The equations of motion are given with these functions as:   
% M * dqddt = f_cg(q, dqdt) + u;

%% KINEMATICS (for collision detection, computation, and graphical output)
% Joint-positions:
HipF  = [x + l1 * cos(CoG_MB_ang);
         y + l1 * sin(CoG_MB_ang)];
HipB  = [x - l1 * cos(CoG_MB_ang);
         y - l1 * sin(CoG_MB_ang)];
     
FootF = HipF + [+lF * sin(CoG_FootF_ang);
                -lF * cos(CoG_FootF_ang)];
FootB = HipB + [+lB * sin(CoG_FootB_ang);
                -lB * cos(CoG_FootB_ang)];
                
% Contact points:
cont_pointF = FootF + [+0;
                       -rFoot];
cont_pointB = FootB + [+0;
                       -rFoot];

% Contact Jacobian:
% NOTE: this is a non-holonomic contact constraint.  I.e. the Jacobian
% needs to be expanded afterwards with the foot rotation:
JF = jacobian(cont_pointF,q) + [0,0,rFoot,rFoot,0,0,0;
                                0,0,0,    0,    0,0,0];
%JF = simple(JF);
JB = jacobian(cont_pointB,q) + [0,0,rFoot,0,0,rFoot,0;
                                0,0,0,    0,0,0,    0];
%JB = simple(JB);
% Time-derivative of the contact Jacobian:
dJFdt = sym(zeros(size(JF)));
for i = 1:size(JF,2)
    dJFdt(:,i) = jacobian(JF(:,i),q)*dqdt.';
end
%dJFdt = simple(dJFdt);
dJFdtTIMESdqdt = dJFdt*dqdt.';
dJBdt = sym(zeros(size(JB)));
for i = 1:size(JB,2)
    dJBdt(:,i) = jacobian(JB(:,i),q)*dqdt.';
end
%dJBdt = simple(dJBdt);
dJBdtTIMESdqdt = dJBdt*dqdt.';



% CoGs (incl orientation of the segments):
CoGs = [CoG_MB,     CoG_ThighF,     CoG_FootF,     CoG_ThighB,     CoG_FootB;
        CoG_MB_ang, CoG_ThighF_ang, CoG_FootF_ang, CoG_ThighB_ang, CoG_FootB_ang];

% links (or rather: joint positions)
links = [FootF, HipF, HipB, FootB];

% Position of the foot points:     
footPts = [FootF, FootB];

%% Create MATLAB-functions:
if ~exist('AutoGeneratedFcts','dir')
    mkdir('AutoGeneratedFcts')
end

matlabFunction(M,'file','AutoGeneratedFcts\MassMatrix','vars',[q, param]);
matlabFunction(f_cg,'file','AutoGeneratedFcts\F_CoriGrav','vars',[q, dqdt, param]);

matlabFunction(cont_pointF,'file','AutoGeneratedFcts\ContactPointF','vars',[q, param]);
matlabFunction(cont_pointB,'file','AutoGeneratedFcts\ContactPointB','vars',[q, param]);
matlabFunction(JF,'file','AutoGeneratedFcts\ContactJacobianF','vars',[q, param]);
matlabFunction(JB,'file','AutoGeneratedFcts\ContactJacobianB','vars',[q, param]);
matlabFunction(dJFdtTIMESdqdt,'file','AutoGeneratedFcts\ContactJacobianFDtTIMESdqdt','vars',[q, dqdt, param]);
matlabFunction(dJBdtTIMESdqdt,'file','AutoGeneratedFcts\ContactJacobianBDtTIMESdqdt','vars',[q, dqdt, param]);

matlabFunction(CoGs,'file','AutoGeneratedFcts\CoGPositions','vars',[q, param]);
matlabFunction(links,'file','AutoGeneratedFcts\LinkPositions','vars',[q, param]);
matlabFunction(footPts,'file','AutoGeneratedFcts\FootPtPositions','vars',[q, param]);